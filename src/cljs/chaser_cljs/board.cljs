;;----------------------------------------------------------------------
;; File board.cljs
;; Written by Chris Frisz
;; 
;; Created 25 Aug 2013
;; Last modified 15 Sep 2013
;; 
;; In-game board representation
;;----------------------------------------------------------------------

(ns chaser-cljs.board
  (:require-macros [chaser-cljs.macros :refer (defrecord+)])
  (:require [clojure.set :as set]
            [chaser-cljs.protocols :as proto]
            [chaser-cljs.room :as room]))

(defrecord+ Board [room* room-map size])

;; NB: algorithm only works for uniformly-sized rooms. will need
;; NB: something more intelligent if rooms get more interesting
(let [default-room-width 50
      default-room-height default-room-width]
  (defn coords->room
    [[x y]]
    (room/make-room (* x default-room-width) (* y default-room-height)
      default-room-width
      default-room-height)))

(defn make-board
  [room*]
  (->Board room*
    (reduce (fn [room-map room]
              (assoc-in room-map 
                ((juxt proto/get-x proto/get-y) room)
                room))
      {}
      room*)
    (count room*)))

(defn get-space
  [board target-x target-y]
  (get-in (:room-map board) [target-x target-y]))


;;--------------------------------------------------
;; Procedural map generation functions
;;--------------------------------------------------

;; NB: should use a coord ADT instead of ad hoc vectors
(defn adjacent-coords
  [[x y]]
  #{[x (inc y)]     ;; up
    [(inc x) y]     ;; right
    [x (dec y)]     ;; down
    [(dec x) y]})   ;; left

(defn normalize-coords
  "Takes a sequence of coords structures, coords*, and returns a vector
   of coords structures representing the original coordinates translated
   by subtracting the minimum x and y values from each x and y value,
   respectively. In effect, this translates the coordinates as close to
   the origin as possible, all within the first quadrant of the 
   cartesian plane."
  [coords*]
  (let [min-x (apply min (map first coords*))
        min-y (apply min (map fnext coords*))]
    (if (and (zero? min-x) (zero? min-y))
      (vec coords*)
      (mapv (fn [coords]
              (as-> coords coords
                (assoc coords 0 (- (first coords) min-x))
                (assoc coords 1 (- (fnext coords) min-y))))
        coords*))))

(defn generate-coords*
  "Takes an integer, target-size, and returns a vector of target-size
   number of coords structures such that the x and y value of each
   coords structure is >= 0. The vector is generated by starting with a
   single point, randomly selecting a point adjacent to it, and 
   repeating the process with each additional point until the 
   target-size is reached."
  [target-size]
  (let [origin [0 0]]
    (loop [coords* #{origin}
           adjacent* (adjacent-coords origin)]
      (if (= (count coords*) target-size)
          (normalize-coords coords*)
          (let [new-coords (rand-nth (vec adjacent*))]
            (recur (conj coords* new-coords)
              ;; NB: generates an adjacent set even if target-size hit
              (set/union (set/difference 
                           (adjacent-coords new-coords)
                           coords*)
                (disj adjacent* new-coords))))))))

(def make-randomized-board 
  (comp make-board
    (partial map coords->room)
    generate-coords*))
