;;----------------------------------------------------------------------
;; File grid_generator.cljs
;; Written by Chris Frisz
;; 
;; Created 15 Sep 2013
;; Last modified 15 Sep 2013
;; 
;; Procedural map generation functions
;;----------------------------------------------------------------------

(ns chaser-cljs.grid-generator
  (:require-macros [chaser-cljs.macros :refer (defrecord+)])
  (:require [clojure.set :as set]
            [chaser-cljs.protocols :as proto]))

(defrecord+ GeneratorTile [x y]
  proto/PCoords
  (get-x [tile] (:x tile))
  (get-y [tile] (:y tile))
  (update-x [tile new-x] (assoc tile :x new-x))
  (update-y [tile new-y] (assoc tile :y new-y)))


(def make-adjacent-tiles
  (letfn [(make-stencil [tile]
            (let [get-range (juxt dec identity inc)]
              (for [x (get-range (proto/get-x tile))
                    y (get-range (proto/get-y tile))]
                [x y])))
          (get-cardinal-coords [stencil]
            (take-nth 2 (next stencil)))]
    (comp (partial map (partial apply make-generator-tile))
      get-cardinal-coords
      make-stencil)))  

(defn normalize-tile-coords
  "Takes a sequence of tile structures, tile*, and returns a vector
   of tile structures representing the original coordinates translated
   by subtracting the minimum x and y values from each x and y value,
   respectively. In effect, this translates the coordinates as close to
   the origin as possible, all within the first quadrant of the 
   cartesian plane."
  [tile*]
  (let [min-x (apply min (map proto/get-x tile*))
        min-y (apply min (map proto/get-y tile*))]
    (if (and (zero? min-x) (zero? min-y))
      (vec tile*)
      (letfn [(updater [min getter] (comp (partial + (- min)) getter))]
        (mapv (comp (partial apply make-generator-tile)
                (juxt (updater min-x proto/get-x) 
                  (updater min-y proto/get-y)))
          tile*)))))

(defn generate-tile*
  "Takes an integer, target-size, and returns a vector of target-size
   number of tile structures such that the x and y value of each
   tile structure is >= 0. The vector is generated by starting with a
   single point, randomly selecting a point adjacent to it, and 
   repeating the process with each additional point until the 
   target-size is reached."
  [target-size]
  (let [origin (make-generator-tile 0 0)]
    (loop [tile* #{origin}
           adjacent* (set (make-adjacent-tiles origin))]
      (if (= (count tile*) target-size)
          (normalize-tile-coords tile*)
          (let [new-tile (rand-nth (vec adjacent*))]
            (recur (conj tile* new-tile)
              ;; NB: generates an adjacent set even if target-size hit
              (set/union (set/difference 
                           (set (make-adjacent-tiles new-tile))
                           tile*)
                (disj adjacent* new-tile))))))))
